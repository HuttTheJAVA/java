원래 인터페이스의 멤버 변수는 모두 public static final이여야 하고   
(인터페이스는 추상 명세이므로 멤버 변수가 달라지는 경우가 발생하면 안됀다고 생각한다.)   
메소드 또한 모두 추상 메소드여야 한다.   
자바에서는 이 추상 메소드를 인터페이스를 구현하는 클래스에 강제로 구현하게 한다.(구현 방식은 클래스별로 마음대로)
하지만 구현에 강제를 두면서 이는 나중에 장점이자 자승자박이 되버리는 꼴이 된다.아무리 인터페이스 추상 명세 설계를 초기에 잘했다고 해도,   
언젠가는 새로운 추상 기능이 생길 수 있다.   
예를들어 미래에 전기차가 생길줄 모르고 자동차 인터페이스에 "주유 하다"라는 추상 메소드의 매개변수로 oil(기름)만 받도록 설계했다고 해보자.
그리고 긴 시간동안 많은 클래스(자동차 회사 (ex.벤츠,폭스바겐,현대))들이 이 자동차 인터페이스 명세에 맞게 모두 구현해놨다고 하자,   
근데 미래에 전기차가 발명돼 자동차 인터페이스에 electricity 매개변수를 받는 "주유 하다"라는 추상 메소드를 추가로 오버로딩하고 싶다고 하자.   
인터페이스에 새로운 추상 메소드를 추가하면 자바에서는 추상 메소드를 클래스가 강제 구현하도록 하므로 자동차 인터페이스를 구현하는 모든 클래스는 2가지 기로에 놓인다.   
1. 클래스를 abstract 즉 추상 클래스로 바꾼다.   
2. 새로 추가된 추상 메소드를 구현한다.

둘 중 뭐가 됐던간에 확실히 머리 아파지는 상황이다. 따라서 default 메소드를 인터페이스에서 허용하도록 자바1.8서 부터 바꿨다. 이렇게 하면, 나중에 인터페이스에   
새로운 메소드를 추가해도 이 인터페이스를 구현하는 클래스들에서 강제로 구현하지 않아도 되며, 또 이 default메소드를 최신화 즉시, 바로 클래스에서도 쓸 수 있다.   
단, default메소드는 추상 메소드가 아니므로 메소드 몸통을 구현해야 되고, 클래스에서 입맛에 맞게 오버라이딩도 가능하다.

static 메소드는 사실 인스턴스와 관련없는 메소드라 인터페이스에서 만들지 못할 이유가 없었는데 "인터페이스에는 추상 메소드만 가능하다"라는 개념을 지키기 위해   
불필요하게 새로운 클래스를 만들어 거기에다가 static 메소드들을 구현해 놓는 식으로 했었다가 인터페이스에도 static 메소드를 구현할 수 있도록 바꿨다.
확실하진 않지만 위의 예시로 Collection 인터페이스의 Collections 클래스가 앞서 설명한 이유로 만들어진 클래스라고 어디서 봤었던거 같기도..   
(※ Collections 클래스에 구현된 메소드 들은 모두 다 static 제어자를 가진다.)

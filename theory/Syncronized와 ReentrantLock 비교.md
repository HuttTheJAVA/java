여러 쓰레드나 프로세스가 공유 데이터에 접근하면 항상 발생하는 문제가 있다.   
바로 **"동기화 문제"** 인데, java에서는 이 동기화 문제를 해결하기 위해 Syncronized와 ReetrantLock을 제공한다.   
이 둘은 쓰레드나 프로세스가 공유 데이터를 접근하는 코드 부분(임계 구역(Critical Zone))에 진입할 때   
추가로 다른 쓰레드가 이 임계 구역에 들어오지 못하게 방지(lock & unlock)해주는 역할을 한다.   
왜 다른 쓰레드가 임계 구역에 못들어오게 막을까? 그 이유는 위에서 언급했듯이 동기화 문제를 해결하기 위함이다.   
내가 작업을 하고 있는 와중에 다른 쓰레드가 와서 내가 참고해야 할 데이터들을 마구잡이로 뒤바꿔놨다고 생각해보자.   
(이게 다 데이터를 **"공유"** 하기 때문에 발생하는 일이다.)<br></br>


그럼 이 동기화를 유지하는데 도움을 주는 Syncronized와 ReentrantLock에 대해 비교해보자.   
## Syncronized
먼저 Syncronized의 장점으로는 **lock**과 **unlock**이 자동적으로 이루어진다는 것이다.   
따라서 프로그래머는 요청,해제 부분에 대해서는 일절 신경쓰지 않아도 된다는 소리다.   
그리고 임계구역에 lock을 걸어놓고 Exception이 발생해서 의도치 않게 종료되어도 임계구역의 unlock을 보장한다.   
그럼 단점으로는 뭐가 있을까? 먼저 Syncronized는 java에서 **"제어자"** 이다.   
즉, 최소 메소드 단위(블럭 {} 단위)로 lock이 걸린다는 점이다. 예를 들어 어떤 쓰레드가 임계구역을 포함하는   
메소드에 진입한다고 하자. (임계구역이 메소드 안에 존재하니 이 메소드 제어자는 Syncronized를 포함할 것이다.)   
그럼 다른 쓰레드는 lock이 풀릴 때 까지 이 메소드에 접근하지 못한다.   
**설령 이 다른 쓰레드가 이 임계구역에는 관심없고 단지 이 메소드의 다른 부분만 사용하고 싶다고 해도 말이다!**   

## ReentrantLock
ReentrantLock의 장점으로는 위의 Syncronized 방식은 블럭 단위로 lock을 걸지만 ReentrantLock은   
블럭 내에서 Lock이 가능하다. 즉 정말 딱 필요한 임계구역 부분만 lock할 수 있다는 것이다.   
단점으로는 Syncronized처럼 lock & unlock을 자동으로 해주지 않기 때문에(Syncronize는 제어자이기 때문에 lock해야 될 scope의 영역(블럭)을 알기 때문에 자동으로 된다고 생각한다.)   
프로그래머가 일일이 lock과 unlock을 해줘야 한다. 또한 lock한 후에 Exception으로 인해 unlock이 제대로 이뤄지지 않을 것 까지 고려해 unlock코드를 try-finally의 finally부분에 넣어야 된다.   
    <br></br>
ps.책에서 봤을 때 메소드가 임계구역외에 포함하는 다른 부분이 그렇게 많지 않다면 그냥 Syncronized를 쓰는 것을 권장한다는 내용이 있었다.

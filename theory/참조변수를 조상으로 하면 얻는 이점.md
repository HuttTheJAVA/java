코드를 보면   <br></br>
![asd](https://user-images.githubusercontent.com/92637789/223609265-d8af2dfe-17d4-46d8-b705-8bb838d13b53.png)   <br></br>
이런식으로 실질적인 객체는 ArrayList인데 조상 인터페이스인 List로 참조하는 경우가 많다.   
이렇게 하는 이유는 실질 객체의 교체를 원활히 하기 위함이다.   
예를 들어, 나중에 이 코드에서 ArrayList 컬렉션 중간에 삽입 삭제가 빈번해져서 효율을 위해 ArrayList를 LinkedList로 바꾸고 싶다고 해보자.   
그러면 위 코드에서 ArrayList를 LinkedList로만 바꿔주면 된다. 그리고 그 이후의 아래 코드들은 신경쓰지 않아도 된다.<br></br>
신경쓰지 않아도 되는 이유는 아래에 참조 변수 list(변수명)를 다루는 코드가 엄청 많다고 해보자. 이 list(변수명)를 다루는 코드들은   
List인터페이스에 명시된 범위내에서만 접근하는 코드들일 것이다. List에 없는 추상 메소드명이나 필드에 접근하지 않을 것이다.   
따라서 List의 모든 것을 포함하는 LinkedList로 쉽게 교체가 가능한 것이다.(이후의 코드는 List의 명시된 범위 내에서만 접근하기 때문에)   
(사진에서는 이후 코드가 짧은데, 이후 코드가 1000줄이 있다고 생각해보자.)   
근데 참조변수를 조상으로 안하고 실질 객체와 똑같은 클래스로 참조했다고 해보자.   <br></br>
이렇게 되면 이후의 코드에서 ArrayList에만 독점적으로 있는 어떠한 메소드나 필드에 접근하는 코드가 있을 수 도 있게 된다.   
앞서 말했듯이 이후의 코드들이 짧으면 상관없다지만, 만약 1000줄의 list참조변수를 다루는 코드가 있다고 하면,   
LinkedList로 바꾸기 전에 이 list(변수명)에 접근하는 코드 중 ArrayList에만 독점적으로 있는 뭔가에 접근하는 코드가 있는지   
눈이 빠지게 검토해야 될 것이다. 애초에 list변수의 참조 변수 타입을 List로 했으면 이를 방지할 수가 있는 것이다.   
근데 ArrayList에만 있는 독점적인 뭔가에 접근해야 된다면 그건 어쩔 수 없이 ArrayList로 참조해야 될 것이다.   
위에 설명한 모든 내용은 만약 **코드에 ArrayList에 독점적인 뭔가에 접근하는 코드가 없다면 이왕이면 조상으로 참조해라** 라는 취지이다.
